{"version":3,"sources":["Navbar/Navbar.module.css","Input/Input.module.css","PathfindingVisualizer/Node/Node.jsx","Algorithms/Dijkstra.js","Navbar/Navbar.js","Input/Input.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["module","exports","Node","props","state","this","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","NodeClassName","id","className","Component","getMin","nodes","minNode","undefined","minIdx","i","node","visited","distance","Navbar","styles","navbar","AppBar","position","Toolbar","Typography","variant","title","GetInput","newXst","stX","newYst","stY","newXend","endX","newYend","endY","startXchange","bind","startYchange","endXchange","endYchange","handleChange","new_value","setState","input","noValidate","autoComplete","TextField","label","onChange","e","target","value","type","onClick","PathfindingVisualizer","grid","mouseIsPressed","START_NODE_ROW","START_NODE_COL","END_NODE_COL","END_NODE_ROW","createGrid","newGrid","getGridWithWall","visitedNodes","nodesInShortestPath","length","setTimeout","animateShortestPath","document","getElementById","startNode","endNode","edges","Infinity","previousNode","push","visitedNodesInOrder","k","alert","j","dijkstra","totalNodes","tempRow","tempCol","makeEdges","currentNode","getShortestPathNodes","n","m","animateVisitedNodes","slice","parseInt","resetGrid","visualizeDijkstra","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","startc","startr","endc","endr","currentRow","createNode","console","log","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c7537e25.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"navbar\":\"Navbar_navbar__12sOP\",\"title\":\"Navbar_title__3m7EF\",\"button\":\"Navbar_button__fnow1\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"input\":\"Input_input__I2RVT\",\"button\":\"Input_button__25LVy\",\"button1\":\"Input_button1__2ug52\"};","import React, { Component } from 'react'\r\nimport './Node.css'\r\n\r\nexport class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n    render() {\r\n        const {\r\n            col,\r\n            row,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props;\r\n        const NodeClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : '';\r\n\r\n        return(\r\n            <div \r\n            id={`node-${row}-${col}`}\r\n            className={`node ${NodeClassName}`}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}></div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Node\r\n","export function dijkstra(grid, startNode, endNode, edges){\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            node.distance = Infinity;\r\n            node.visited = false;\r\n            node.previousNode = startNode;\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    const  visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    for(let k = 0;k < nodes.length ;k++){\r\n        const [minNode,minIdx] = getMin(nodes);\r\n        if(minNode.distance === Infinity){\r\n            alert(\"NO Path Possible!\");\r\n            return visitedNodesInOrder;\r\n        }\r\n        minNode.visited= true;\r\n        visitedNodesInOrder.push(minNode);\r\n        if(minNode === endNode){\r\n            return visitedNodesInOrder;\r\n        }\r\n        for(let j = 0; j < nodes.length; j++){\r\n            const node = nodes[j];\r\n            if(edges[minIdx][j] !== 0){\r\n                if(!node.visited && (node.distance > minNode.distance + edges[minIdx][j])){\r\n                    node.distance = minNode.distance + edges[minIdx][j];\r\n                    node.previousNode = minNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nexport function getShortestPathNodes(startNode,endNode) {\r\n    const visitedNodes = [];\r\n    let currentNode = endNode;\r\n    while(currentNode !== startNode){\r\n        visitedNodes.push(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    visitedNodes.push(currentNode);\r\n    return visitedNodes;\r\n}\r\n\r\n\r\nfunction getMin(nodes){\r\n    let minNode = undefined;\r\n    let minIdx = -1;\r\n    let i = 0;\r\n    for(const node of nodes){\r\n        if(!node.visited && !node.isWall && (minNode === undefined || minNode.distance > node.distance)){\r\n            minNode = node;\r\n            minIdx = i;\r\n        }\r\n        i++;\r\n    }\r\n    return [minNode,minIdx];\r\n}","import React from 'react';\r\nimport styles from './Navbar.module.css';\r\nimport {AppBar, Toolbar, Typography} from '@material-ui/core';\r\nconst Navbar = () => {\r\n    return (\r\n        <div className = {styles.navbar}>\r\n            <AppBar position=\"static\">\r\n                <Toolbar>\r\n                    <Typography variant=\"h6\" className={styles.title}>\r\n                    Dijkstra's Pathfinding Algorithm\r\n                    </Typography>\r\n                </Toolbar>\r\n            </AppBar>\r\n        </div>\r\n    )\r\n}\r\nexport default Navbar;","import React , { Component } from 'react'\r\nimport styles from './Input.module.css'\r\nimport {TextField} from '@material-ui/core'\r\nexport class GetInput extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.startXchange = this.startXchange.bind(this);\r\n        this.startYchange = this.startYchange.bind(this);\r\n        this.endXchange = this.endXchange.bind(this);\r\n        this.endYchange = this.endYchange.bind(this);\r\n        this.handleChange = this.handleChange.bind(this);\r\n    }\r\n    state = {\r\n        newXst: this.props.stX,\r\n        newYst: this.props.stY,\r\n        newXend: this.props.endX,\r\n        newYend: this.props.endY,\r\n    }\r\n    startXchange(new_value) {\r\n        this.setState({newXst: new_value});\r\n    }\r\n    \r\n    startYchange(new_value) {\r\n        this.setState({newYst: new_value});\r\n    }\r\n    \r\n    endXchange(new_value) {\r\n        this.setState({newXend: new_value});\r\n    }\r\n    \r\n    endYchange(new_value) {\r\n        this.setState({newYend: new_value});\r\n    }\r\n    handleChange () {\r\n        this.props.handleChange(this.state.newXst,this.state.newYst,this.state.newXend,this.state.newYend);\r\n    }\r\n    render () {\r\n        return (\r\n            <form className={styles.input} noValidate autoComplete=\"off\">\r\n                <TextField id=\"standard-basic\" label=\"Starting Postion (X)\" onChange={(e) => this.startXchange(e.target.value)} />\r\n                <TextField id=\"standard-basic\" label=\"Staring Position (Y)\" onChange={(e) => this.startYchange(e.target.value)} />\r\n                <TextField id=\"standard-basic\" label=\"Final Position (X)\" onChange={(e) => this.endXchange(e.target.value)} />\r\n                <TextField id=\"standard-basic\" label=\"Final Position (Y)\" onChange={(e) => this.endYchange(e.target.value)} />\r\n                <button className=\"button button1\" type=\"button\" onClick={this.handleChange}>Change</button>\r\n            </form>\r\n        )\r\n        \r\n    }\r\n};\r\nexport default GetInput\r\n","import React, { Component } from 'react'\r\nimport Node from './Node/Node'\r\nimport './PathfindingVisualizer.css'\r\nimport {dijkstra,getShortestPathNodes} from '../Algorithms/Dijkstra'\r\nimport Navbar from '../Navbar/Navbar'\r\nimport GetInput from '../Input/Input'\r\n\r\nexport class PathfindingVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            START_NODE_ROW: 3,\r\n            START_NODE_COL: 7,\r\n            END_NODE_COL: 39,\r\n            END_NODE_ROW: 15,\r\n\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = createGrid(this.state.START_NODE_COL, this.state.START_NODE_ROW, this.state.END_NODE_COL, this.state.END_NODE_ROW);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        const newGrid = getGridWithWall(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mouseIsPressed: true});\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        const newGrid = getGridWithWall(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n    }\r\n    \r\n    handleMouseUp() {\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n    \r\n    animateVisitedNodes(visitedNodes, nodesInShortestPath) {\r\n        for (let i = 0; i <= visitedNodes.length; i++) {\r\n          if (i === visitedNodes.length) {\r\n            setTimeout(() => {\r\n              this.animateShortestPath(nodesInShortestPath);\r\n            }, 10 * i);\r\n            return;\r\n          }\r\n          setTimeout(() => {\r\n            const node = visitedNodes[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-visited';\r\n          }, 10 * i);\r\n        }\r\n      }\r\n    \r\n    animateShortestPath(nodesInShortestPath) {\r\n        for (let i = 0; i < nodesInShortestPath.length; i++) {\r\n            setTimeout(() => {\r\n            const node = nodesInShortestPath[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                'node node-shortest-path';\r\n            }, 50 * i);\r\n        }\r\n    }\r\n    visualizeDijkstra() {\r\n        const {grid} = this.state;\r\n        const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endNode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const edges = makeEdges(grid);\r\n        const visitedNodes = dijkstra(grid, startNode, endNode, edges);\r\n        const nodesInShortestPath = getShortestPathNodes(startNode,endNode);\r\n        const n = nodesInShortestPath.length;\r\n        const m = visitedNodes.length;\r\n        this.animateVisitedNodes(visitedNodes.slice(1,m-1), nodesInShortestPath.slice(1,n-1));\r\n    }\r\n    \r\n    resetGrid() {\r\n        const newGrid = createGrid(this.state.START_NODE_COL, this.state.START_NODE_ROW, this.state.END_NODE_COL, this.state.END_NODE_ROW);\r\n        this.setState({grid: newGrid});\r\n        const nodes = [];\r\n        const {grid} = this.state;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                nodes.push(node);\r\n            }\r\n        }\r\n        for(let i = 0;i < nodes.length;i++) {\r\n            const node = nodes[i];\r\n            const {col, row, isFinish, isStart} = node;\r\n            const NodeClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : '';\r\n            document.getElementById(`node-${row}-${col}`).className = `node ${NodeClassName}`;\r\n        }\r\n    }\r\n    handleChange(stX, stY, endX, endY) {\r\n        if(parseInt(stX) < 0 || parseInt(stX) >= 20 || parseInt(stY) < 0 || parseInt(stY) >= 50 || parseInt(endX) < 0 || parseInt(endX) >= 20 || parseInt(endY) < 0 || parseInt(endY) >= 50) {\r\n            alert(\"Values entered dont fit in the Grid!!\");\r\n        }else {\r\n            this.setState({START_NODE_ROW: parseInt(stX), START_NODE_COL: parseInt(stY), END_NODE_ROW: parseInt(endX), END_NODE_COL: parseInt(endY)}, () => {\r\n                this.resetGrid();\r\n            });\r\n        }\r\n    }\r\n    render() {\r\n        const {grid, mouseIsPressed} = this.state;    \r\n        return (\r\n            <>\r\n            <Navbar></Navbar>\r\n            <button className=\"button button1\" onClick={() => this.visualizeDijkstra()}>\r\n                Visualize Dijkstra's Algorithm\r\n            </button>\r\n            <button className=\"button button1\" onClick={() => this.resetGrid()}>\r\n                Reset Grid\r\n            </button>\r\n            <GetInput handleChange = {this.handleChange} stX = {this.state.START_NODE_ROW} stY = {this.state.START_NODE_COL}\r\n                        endX = {this.state.END_NODE_ROW} endY = {this.state.END_NODE_COL}></GetInput>\r\n            <div className=\"grid\">\r\n                {grid.map((row, rowIdx) => {\r\n                    return (\r\n                    <div key={rowIdx}>\r\n                        {row.map((node, nodeIdx) => {\r\n                            const {col, row, isFinish, isStart, isWall} = node;\r\n                            return (\r\n                                <Node\r\n                                key = {nodeIdx}\r\n                                col = {col}\r\n                                row = {row}\r\n                                isFinish = {isFinish}\r\n                                isStart = {isStart}\r\n                                isWall={isWall}\r\n                                mouseIsPressed={mouseIsPressed}\r\n                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                onMouseUp={() => this.handleMouseUp()}></Node>\r\n                            );\r\n                        })}\r\n                        </div>\r\n                    );\r\n                })}              \r\n            </div>\r\n            </>\r\n        ); \r\n    }\r\n}\r\n\r\nconst createGrid = (startc, startr, endc, endr) => {\r\n    const grid = [];\r\n    for(let row = 0; row < 20; row++){\r\n        const currentRow = [];\r\n        for(let col = 0; col < 50; col++){\r\n            currentRow.push(createNode(row,col,startr,startc,endr,endc));\r\n            console.log(row,col,startr,startc,endr,endc);\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (row,col,startr,startc,endr,endc) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === startr && col === startc,\r\n        isFinish: row === endr && col === endc,\r\n        isWall: false,\r\n    };\r\n};\r\n\r\nfunction makeEdges(grid) {\r\n    const row = grid.length;\r\n    const col = grid[0].length;\r\n    const edges = [];\r\n    let totalNodes = row*col;\r\n    for(let i=0;i<row*col;i++){\r\n        edges[i] = [];\r\n        for(let j=0;j<row*col;j++){\r\n            edges[i][j] = 0;\r\n        }\r\n    }\r\n    let tempRow = 0;\r\n    let tempCol = 0;\r\n    for(let i=0;i<totalNodes;i++){\r\n        if(tempCol + 1 < col){\r\n            edges[i][tempRow*col + tempCol + 1] = 1;\r\n        }\r\n        if(tempCol - 1 >= 0){\r\n            edges[i][tempRow*col + tempCol - 1] = 1;\r\n        }\r\n        if(tempRow + 1 < row){\r\n            edges[i][(tempRow+1)*col + tempCol] = 1;            \r\n        }\r\n        if(tempRow - 1 >= 0){\r\n            edges[i][(tempRow-1)*col + tempCol] = 1;    \r\n        }\r\n        tempCol += 1;\r\n        if(tempCol >= col){\r\n            tempCol = 0;\r\n            tempRow += 1;\r\n        }\r\n    }\r\n    return edges;\r\n}\r\n\r\nconst getGridWithWall = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n  \r\n\r\nexport default PathfindingVisualizer\r\n\r\n\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}